// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gpio.proto

#ifndef PROTOBUF_gpio_2eproto__INCLUDED
#define PROTOBUF_gpio_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gpio_2eproto();
void protobuf_AssignDesc_gpio_2eproto();
void protobuf_ShutdownFile_gpio_2eproto();

class GpioCmd;

enum GpioCmd_Cmd {
  GpioCmd_Cmd_GPIO = 0,
  GpioCmd_Cmd_SPI = 1,
  GpioCmd_Cmd_I2C = 2
};
bool GpioCmd_Cmd_IsValid(int value);
const GpioCmd_Cmd GpioCmd_Cmd_Cmd_MIN = GpioCmd_Cmd_GPIO;
const GpioCmd_Cmd GpioCmd_Cmd_Cmd_MAX = GpioCmd_Cmd_I2C;
const int GpioCmd_Cmd_Cmd_ARRAYSIZE = GpioCmd_Cmd_Cmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* GpioCmd_Cmd_descriptor();
inline const ::std::string& GpioCmd_Cmd_Name(GpioCmd_Cmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    GpioCmd_Cmd_descriptor(), value);
}
inline bool GpioCmd_Cmd_Parse(
    const ::std::string& name, GpioCmd_Cmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GpioCmd_Cmd>(
    GpioCmd_Cmd_descriptor(), name, value);
}
enum GpioCmd_GpioMode {
  GpioCmd_GpioMode_OUTPUT = 1,
  GpioCmd_GpioMode_INPUT = 2
};
bool GpioCmd_GpioMode_IsValid(int value);
const GpioCmd_GpioMode GpioCmd_GpioMode_GpioMode_MIN = GpioCmd_GpioMode_OUTPUT;
const GpioCmd_GpioMode GpioCmd_GpioMode_GpioMode_MAX = GpioCmd_GpioMode_INPUT;
const int GpioCmd_GpioMode_GpioMode_ARRAYSIZE = GpioCmd_GpioMode_GpioMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GpioCmd_GpioMode_descriptor();
inline const ::std::string& GpioCmd_GpioMode_Name(GpioCmd_GpioMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GpioCmd_GpioMode_descriptor(), value);
}
inline bool GpioCmd_GpioMode_Parse(
    const ::std::string& name, GpioCmd_GpioMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GpioCmd_GpioMode>(
    GpioCmd_GpioMode_descriptor(), name, value);
}
// ===================================================================

class GpioCmd : public ::google::protobuf::Message {
 public:
  GpioCmd();
  virtual ~GpioCmd();
  
  GpioCmd(const GpioCmd& from);
  
  inline GpioCmd& operator=(const GpioCmd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioCmd& default_instance();
  
  void Swap(GpioCmd* other);
  
  // implements Message ----------------------------------------------
  
  GpioCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpioCmd& from);
  void MergeFrom(const GpioCmd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef GpioCmd_Cmd Cmd;
  static const Cmd GPIO = GpioCmd_Cmd_GPIO;
  static const Cmd SPI = GpioCmd_Cmd_SPI;
  static const Cmd I2C = GpioCmd_Cmd_I2C;
  static inline bool Cmd_IsValid(int value) {
    return GpioCmd_Cmd_IsValid(value);
  }
  static const Cmd Cmd_MIN =
    GpioCmd_Cmd_Cmd_MIN;
  static const Cmd Cmd_MAX =
    GpioCmd_Cmd_Cmd_MAX;
  static const int Cmd_ARRAYSIZE =
    GpioCmd_Cmd_Cmd_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Cmd_descriptor() {
    return GpioCmd_Cmd_descriptor();
  }
  static inline const ::std::string& Cmd_Name(Cmd value) {
    return GpioCmd_Cmd_Name(value);
  }
  static inline bool Cmd_Parse(const ::std::string& name,
      Cmd* value) {
    return GpioCmd_Cmd_Parse(name, value);
  }
  
  typedef GpioCmd_GpioMode GpioMode;
  static const GpioMode OUTPUT = GpioCmd_GpioMode_OUTPUT;
  static const GpioMode INPUT = GpioCmd_GpioMode_INPUT;
  static inline bool GpioMode_IsValid(int value) {
    return GpioCmd_GpioMode_IsValid(value);
  }
  static const GpioMode GpioMode_MIN =
    GpioCmd_GpioMode_GpioMode_MIN;
  static const GpioMode GpioMode_MAX =
    GpioCmd_GpioMode_GpioMode_MAX;
  static const int GpioMode_ARRAYSIZE =
    GpioCmd_GpioMode_GpioMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GpioMode_descriptor() {
    return GpioCmd_GpioMode_descriptor();
  }
  static inline const ::std::string& GpioMode_Name(GpioMode value) {
    return GpioCmd_GpioMode_Name(value);
  }
  static inline bool GpioMode_Parse(const ::std::string& name,
      GpioMode* value) {
    return GpioCmd_GpioMode_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .GpioCmd.Cmd cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::GpioCmd_Cmd cmd() const;
  inline void set_cmd(::GpioCmd_Cmd value);
  
  // optional int32 spiPort = 2;
  inline bool has_spiport() const;
  inline void clear_spiport();
  static const int kSpiPortFieldNumber = 2;
  inline ::google::protobuf::int32 spiport() const;
  inline void set_spiport(::google::protobuf::int32 value);
  
  // optional int32 gpioPort = 3;
  inline bool has_gpioport() const;
  inline void clear_gpioport();
  static const int kGpioPortFieldNumber = 3;
  inline ::google::protobuf::int32 gpioport() const;
  inline void set_gpioport(::google::protobuf::int32 value);
  
  // optional int32 i2cPort = 4;
  inline bool has_i2cport() const;
  inline void clear_i2cport();
  static const int kI2CPortFieldNumber = 4;
  inline ::google::protobuf::int32 i2cport() const;
  inline void set_i2cport(::google::protobuf::int32 value);
  
  // optional int32 spiClock = 5;
  inline bool has_spiclock() const;
  inline void clear_spiclock();
  static const int kSpiClockFieldNumber = 5;
  inline ::google::protobuf::int32 spiclock() const;
  inline void set_spiclock(::google::protobuf::int32 value);
  
  // optional bytes dataOut = 6;
  inline bool has_dataout() const;
  inline void clear_dataout();
  static const int kDataOutFieldNumber = 6;
  inline const ::std::string& dataout() const;
  inline void set_dataout(const ::std::string& value);
  inline void set_dataout(const char* value);
  inline void set_dataout(const void* value, size_t size);
  inline ::std::string* mutable_dataout();
  inline ::std::string* release_dataout();
  
  // optional bytes dataIn = 7;
  inline bool has_datain() const;
  inline void clear_datain();
  static const int kDataInFieldNumber = 7;
  inline const ::std::string& datain() const;
  inline void set_datain(const ::std::string& value);
  inline void set_datain(const char* value);
  inline void set_datain(const void* value, size_t size);
  inline ::std::string* mutable_datain();
  inline ::std::string* release_datain();
  
  // optional .GpioCmd.GpioMode gpioMode = 8;
  inline bool has_gpiomode() const;
  inline void clear_gpiomode();
  static const int kGpioModeFieldNumber = 8;
  inline ::GpioCmd_GpioMode gpiomode() const;
  inline void set_gpiomode(::GpioCmd_GpioMode value);
  
  // @@protoc_insertion_point(class_scope:GpioCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_spiport();
  inline void clear_has_spiport();
  inline void set_has_gpioport();
  inline void clear_has_gpioport();
  inline void set_has_i2cport();
  inline void clear_has_i2cport();
  inline void set_has_spiclock();
  inline void clear_has_spiclock();
  inline void set_has_dataout();
  inline void clear_has_dataout();
  inline void set_has_datain();
  inline void clear_has_datain();
  inline void set_has_gpiomode();
  inline void clear_has_gpiomode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int cmd_;
  ::google::protobuf::int32 spiport_;
  ::google::protobuf::int32 gpioport_;
  ::google::protobuf::int32 i2cport_;
  ::std::string* dataout_;
  ::google::protobuf::int32 spiclock_;
  int gpiomode_;
  ::std::string* datain_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_gpio_2eproto();
  friend void protobuf_AssignDesc_gpio_2eproto();
  friend void protobuf_ShutdownFile_gpio_2eproto();
  
  void InitAsDefaultInstance();
  static GpioCmd* default_instance_;
};
// ===================================================================


// ===================================================================

// GpioCmd

// required .GpioCmd.Cmd cmd = 1;
inline bool GpioCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpioCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpioCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpioCmd::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::GpioCmd_Cmd GpioCmd::cmd() const {
  return static_cast< ::GpioCmd_Cmd >(cmd_);
}
inline void GpioCmd::set_cmd(::GpioCmd_Cmd value) {
  GOOGLE_DCHECK(::GpioCmd_Cmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional int32 spiPort = 2;
inline bool GpioCmd::has_spiport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpioCmd::set_has_spiport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpioCmd::clear_has_spiport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpioCmd::clear_spiport() {
  spiport_ = 0;
  clear_has_spiport();
}
inline ::google::protobuf::int32 GpioCmd::spiport() const {
  return spiport_;
}
inline void GpioCmd::set_spiport(::google::protobuf::int32 value) {
  set_has_spiport();
  spiport_ = value;
}

// optional int32 gpioPort = 3;
inline bool GpioCmd::has_gpioport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpioCmd::set_has_gpioport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpioCmd::clear_has_gpioport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpioCmd::clear_gpioport() {
  gpioport_ = 0;
  clear_has_gpioport();
}
inline ::google::protobuf::int32 GpioCmd::gpioport() const {
  return gpioport_;
}
inline void GpioCmd::set_gpioport(::google::protobuf::int32 value) {
  set_has_gpioport();
  gpioport_ = value;
}

// optional int32 i2cPort = 4;
inline bool GpioCmd::has_i2cport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpioCmd::set_has_i2cport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpioCmd::clear_has_i2cport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpioCmd::clear_i2cport() {
  i2cport_ = 0;
  clear_has_i2cport();
}
inline ::google::protobuf::int32 GpioCmd::i2cport() const {
  return i2cport_;
}
inline void GpioCmd::set_i2cport(::google::protobuf::int32 value) {
  set_has_i2cport();
  i2cport_ = value;
}

// optional int32 spiClock = 5;
inline bool GpioCmd::has_spiclock() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GpioCmd::set_has_spiclock() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GpioCmd::clear_has_spiclock() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GpioCmd::clear_spiclock() {
  spiclock_ = 0;
  clear_has_spiclock();
}
inline ::google::protobuf::int32 GpioCmd::spiclock() const {
  return spiclock_;
}
inline void GpioCmd::set_spiclock(::google::protobuf::int32 value) {
  set_has_spiclock();
  spiclock_ = value;
}

// optional bytes dataOut = 6;
inline bool GpioCmd::has_dataout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GpioCmd::set_has_dataout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GpioCmd::clear_has_dataout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GpioCmd::clear_dataout() {
  if (dataout_ != &::google::protobuf::internal::kEmptyString) {
    dataout_->clear();
  }
  clear_has_dataout();
}
inline const ::std::string& GpioCmd::dataout() const {
  return *dataout_;
}
inline void GpioCmd::set_dataout(const ::std::string& value) {
  set_has_dataout();
  if (dataout_ == &::google::protobuf::internal::kEmptyString) {
    dataout_ = new ::std::string;
  }
  dataout_->assign(value);
}
inline void GpioCmd::set_dataout(const char* value) {
  set_has_dataout();
  if (dataout_ == &::google::protobuf::internal::kEmptyString) {
    dataout_ = new ::std::string;
  }
  dataout_->assign(value);
}
inline void GpioCmd::set_dataout(const void* value, size_t size) {
  set_has_dataout();
  if (dataout_ == &::google::protobuf::internal::kEmptyString) {
    dataout_ = new ::std::string;
  }
  dataout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpioCmd::mutable_dataout() {
  set_has_dataout();
  if (dataout_ == &::google::protobuf::internal::kEmptyString) {
    dataout_ = new ::std::string;
  }
  return dataout_;
}
inline ::std::string* GpioCmd::release_dataout() {
  clear_has_dataout();
  if (dataout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dataout_;
    dataout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes dataIn = 7;
inline bool GpioCmd::has_datain() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GpioCmd::set_has_datain() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GpioCmd::clear_has_datain() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GpioCmd::clear_datain() {
  if (datain_ != &::google::protobuf::internal::kEmptyString) {
    datain_->clear();
  }
  clear_has_datain();
}
inline const ::std::string& GpioCmd::datain() const {
  return *datain_;
}
inline void GpioCmd::set_datain(const ::std::string& value) {
  set_has_datain();
  if (datain_ == &::google::protobuf::internal::kEmptyString) {
    datain_ = new ::std::string;
  }
  datain_->assign(value);
}
inline void GpioCmd::set_datain(const char* value) {
  set_has_datain();
  if (datain_ == &::google::protobuf::internal::kEmptyString) {
    datain_ = new ::std::string;
  }
  datain_->assign(value);
}
inline void GpioCmd::set_datain(const void* value, size_t size) {
  set_has_datain();
  if (datain_ == &::google::protobuf::internal::kEmptyString) {
    datain_ = new ::std::string;
  }
  datain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpioCmd::mutable_datain() {
  set_has_datain();
  if (datain_ == &::google::protobuf::internal::kEmptyString) {
    datain_ = new ::std::string;
  }
  return datain_;
}
inline ::std::string* GpioCmd::release_datain() {
  clear_has_datain();
  if (datain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datain_;
    datain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .GpioCmd.GpioMode gpioMode = 8;
inline bool GpioCmd::has_gpiomode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GpioCmd::set_has_gpiomode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GpioCmd::clear_has_gpiomode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GpioCmd::clear_gpiomode() {
  gpiomode_ = 1;
  clear_has_gpiomode();
}
inline ::GpioCmd_GpioMode GpioCmd::gpiomode() const {
  return static_cast< ::GpioCmd_GpioMode >(gpiomode_);
}
inline void GpioCmd::set_gpiomode(::GpioCmd_GpioMode value) {
  GOOGLE_DCHECK(::GpioCmd_GpioMode_IsValid(value));
  set_has_gpiomode();
  gpiomode_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GpioCmd_Cmd>() {
  return ::GpioCmd_Cmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GpioCmd_GpioMode>() {
  return ::GpioCmd_GpioMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gpio_2eproto__INCLUDED
